# Do not edit this file directly. It has been autogenerated from
# src\pyelitecloud\api_async.py
"""api.py: API for Smart Water Technology data retrieval."""

import asyncio
import base64
import json
import uuid
import jwt
import httpx
import httpx_ws
import logging
import math
import queue
import threading

from datetime import datetime, timezone
from enum import Enum, StrEnum
from typing import Any

from .const import (
    AUTH_API_URL,
    AUTH_DEVICE_NAME,
    DEVICE_TOKEN_EXPIRE_MARGIN,
    PANEL_API_URL,
    ACCESS_TOKEN_EXPIRE_MARGIN,
    CALL_CONTEXT_ASYNC,
    CALL_CONTEXT_SYNC,
    PANEL_API_WS,
    SERVER_API_URL,
    utcnow_ts,
    utcnow_dt,
)
from .data import (
    EliteCloudSite,
    EliteCloudSites,
    LoginMethod,
    EliteCloudHistoryDetail, 
    EliteCloudHistoryItem,
    EliteCloudAuthError, 
    EliteCloudConnectError, 
    EliteCloudDataError, 
    EliteCloudParamError,
)
from .tasks import (
    AsyncTaskHelper,
    TaskHelper,
)
import time


_LOGGER = logging.getLogger(__name__)


class EliteCloudApiFlag(StrEnum):
    """Extra flags to pass to Api"""
    RENEW_HANDLER_START   = "renew_handler_start"   # bool
    DIAGNOSTICS_COLLECT   = "diagnostics_collect"   # bool
    DEVICE_ID             = "device_id"             # str


class EliteCloudApi:
    """Elite Cloud API"""

    # Constants
    CALL_CONTEXT = CALL_CONTEXT_SYNC   # Sync/Async environment detection
    
    def __init__(self, username, password, 
                 client:httpx.Client = None, 
                 flags:dict = {}):
        
        # Configuration
        self._username: str = username
        self._password: str = password

        # Login data
        self._login_time: datetime|None = None
        self._login_method: LoginMethod|None = None

        self._access_token: str|None = None
        self._access_exp_ts: float|None = None
        self._device_token: str|None = None
        self._device_exp_ts: float|None = None
        
        self._user_uuid: str = None
        self._device_uuid: str = None

        # We generate the device_id based on the username, so it will be the same every time
        # and not add an extra device to the EliteCloud registry every time the code runs.
        self._device_id: str = flags.get(EliteCloudApiFlag.DEVICE_ID, str(uuid.uuid5(uuid.NAMESPACE_OID, self._username)) )

        # Cached data
        self._sites: EliteCloudSites = EliteCloudSites()
        self._sites_subscribed: set[str] = set()
        self._sites_callbacks: dict = dict()
        self._sites_status: dict = dict()

        # Automatic renew of access token
        self._renew_handler_start: bool = flags.get(EliteCloudApiFlag.RENEW_HANDLER_START, False)
        self._renew_task = None
        self._renew_schedule: float = 0

        # Http Client.
        self._http_client: httpx.Client = client or httpx.Client(verify=False)
        self._http_client_close: bool = False if client else True     # Do not close an external passed client

        # Websockets Client
        self._ws_task = None
        self._ws_rsp_task = None

        self._ws_req_queue: queue.Queue = queue.Queue()
        self._ws_rsp_queue: queue.Queue = queue.Queue()

        # Locks to protect certain operations from being called from multiple threads
        self._login_lock = threading.Lock()

        # To pass diagnostics data back to our parent
        self._diag_collect: bool = flags.get(EliteCloudApiFlag.DIAGNOSTICS_COLLECT, False)
        self._diag_history: list[EliteCloudHistoryItem] = list()
        self._diag_details: dict[str, EliteCloudHistoryDetail] = dict()
        self._diag_counters: dict[str, int] = dict()
        self._diag_durations: dict[int, int] = { n: 0 for n in range(10) }


    @property
    def user_uuid(self) -> str:
        """The unique id of the user. Only available after successfull login."""
        return self._user_uuid
    
    @property
    def device_uuid(self) -> str:
        """The unique id of the device. Only available after successfull login."""
        return self._device_uuid


    @property
    def closed(self) -> bool:
        """Returns whether the SmartWaterApi has been closed."""
        if self._http_client:
            return self._http_client.is_closed
        else:
            return True
        

    def close(self):
        """Safely logout and close all client handles"""

        # Logout
        self.logout()

        # Cleanup
        if self._renew_task is not None:
            self._renew_task.stop()

        if self._http_client is not None and self._http_client_close:
            self._http_client.close()
            self._http_client = None

        if self._ws_task is not None:
            self._ws_task.stop()

        if self._ws_rsp_task is not None:
            self._ws_rsp_task.stop()


    def login(self):
        """
        Login to Elite Cloud servers.
        Guards for calls from multiple threads.
        """

        # Only one thread at a time can check the tokens and do subsequent login if needed.
        # Once one thread is done, the next thread can then check the (new) token.
        with self._login_lock:
            self._login()


    def _login(self):
        """Login to Elite Cloud servers by trying each of the possible login methods"""        

        # First try to keep using the access token
        # Next, try to renew that token.
        # Finally try the Auth API login method
        error = None
        methods = [LoginMethod.ACCESS_TOKEN, LoginMethod.RENEW_TOKEN, LoginMethod.AUTH_API]
        for method in methods:
            try:
                match method:
                    case LoginMethod.ACCESS_TOKEN: success = self._login_access_token()
                    case LoginMethod.RENEW_TOKEN:  success = self._login_renew_token()
                    case LoginMethod.AUTH_API:     success = self._login_auth_api()
                    case _:                        success = False

                if success:
                    return  # if we reached this point then a login method succeeded
            
            except Exception as ex:
                _LOGGER.debug(str(ex))
                error = ex

            # Clear any previous login tokens before trying the next method
            self._logout(context="login", method=method)

        # if we reached this point then all methods failed.
        if error:
            raise error
        

    def _login_access_token(self) -> bool:
        """Inspect whether the access token is still valid"""

        if self._access_token is None or self._access_exp_ts is None:
            # No acces-token to check; silently continue to the next login method (renew-token)
            return False

        # inspect the exp field inside the access_token
        if self._access_exp_ts - ACCESS_TOKEN_EXPIRE_MARGIN < utcnow_ts():
            _LOGGER.debug(f"Access-Token expired")
            return False    # silently continue to the next login method (renew-token)

        # Re-use this access token
        dt = utcnow_dt()
        context = f"login access_token reuse"
        token = {
            "access_token": self._access_token,
            "access_expire": datetime.fromtimestamp(self._access_exp_ts, timezone.utc)
        }
        self._add_diagnostics(dt, context, None, None, token)

        # _LOGGER.debug(f"Reuse the access-token")
        return True


    def _login_renew_token(self) -> bool:
        """Attempty to renew the access token"""

        if not self._device_token:
            # No device-token; silently continue to the next login method
            return False
        
        # inspect the exp field inside the access_token
        if self._device_exp_ts - DEVICE_TOKEN_EXPIRE_MARGIN < utcnow_ts():
            _LOGGER.debug(f"Device-Token expired")
            return False    # silently continue to the next login method (auth-api)

        _LOGGER.debug(f"Try renew the access-token")
        result = self._http_request(
            context = f"login access_token renew",
            request = {
                "method": "GET",
                "url": AUTH_API_URL + '/user/token/new/',
                "headers": {
                    "Authorization": self._device_token,
                },
            },
        )
        self._access_token = result.get('access_token')
        self._access_exp_ts = float(self._get_jwt(self._access_token, 'exp', 0))

        if not self._access_token:
            error = f"No tokens found in response from token renew"
            _LOGGER.debug(error)    # logged as warning after last retry
            raise EliteCloudAuthError(error)
        
        # The renew of the tokens succeeded. Schedule the next renew
        self._login_time = utcnow_dt()

        _LOGGER.info(f"Renewed the access-token")
        return self._login_finalize()


    def _login_auth_api(self) -> bool:
        """Login via Auth-Api"""

        _LOGGER.debug(f"Try login via Auth API for '{self._username}'")

        result = self._http_request(
            context = f"login auth-api",
            request = {
                "method": "POST",
                "url": AUTH_API_URL + '/user/login/',
                "data": {
                    "email": self._username,
                    "password": self._password,
                },
            },            
        )
        self._access_token = result.get('access_token')
        self._access_exp_ts = float(self._get_jwt(self._access_token, 'exp', 0))
        self._user_uuid = self._get_jwt(self._access_token, 'uid')

        if not self._access_token:
            error = f"No tokens found in response from login"
            _LOGGER.debug(error)    # logged as warning after last retry
            raise EliteCloudAuthError(error)

        # if we reach this point then the token was OK
        self._login_time = utcnow_dt()
        self._login_method = LoginMethod.AUTH_API

        _LOGGER.info(f"Login succeeded")
        return self._login_finalize()


    def _login_finalize(self) -> bool:
        """Common functionality that needs to be performed regardless of the type of login"""

        # Get device uuid
        if self._device_uuid is None:
            result = self._http_request(
                context = f"login device-new",
                request = {
                    "method": "POST",
                    "url": AUTH_API_URL + '/user/device/new/',
                    "data": {
                        "device_id": self._device_id,
                        "device_name": AUTH_DEVICE_NAME,
                    },
                },            
            )
            self._device_uuid = result.get('uuid')

            if not self._device_uuid:
                error = f"No device uuid found in response from login"
                _LOGGER.debug(error)    # logged as warning after last retry
                raise EliteCloudAuthError(error)

        # Get device token
        result = self._http_request(
            context = f"login device-token",
            request = {
                "method": "POST",
                "url": AUTH_API_URL + f'/user/device/{self._device_uuid}/token/',
                "data": {
                    "email": self._username,
                    "password": self._password,
                },
            },            
        )
        self._device_token = result.get('token')
        self._device_exp_ts = float(self._get_jwt(self._device_token, 'exp', 0))

        if not self._device_token:
            error = f"No device token found in response from login"
            _LOGGER.debug(error)    # logged as warning after last retry
            raise EliteCloudAuthError(error)

        # Schedule the next renew of the access token
        self._renew_schedule = self._access_exp_ts - ACCESS_TOKEN_EXPIRE_MARGIN

        # If needed, start our login_renew_handler thread
        if self._renew_handler_start and self._renew_task is None:
            self._renew_task = TaskHelper(self._login_renew_handler)
            self._renew_task.start()

        # If needed, start our interal websocket response handler
        if self._ws_rsp_task is None:
            self._ws_rsp_task = TaskHelper(self._ws_rsp_handler)
            self._ws_rsp_task.start()

        # if needed, start our websocket_handler thread
        if self._ws_task is None:
            self._ws_task = TaskHelper(self._ws_handler)
            self._ws_task.start()

        return True


    def _login_renew_handler(self) -> bool:
        """
        Parallel task that will renew the access token when scheduled.
        """
        _LOGGER.debug(f"Token renew handler started")

        while not self._renew_task.is_stop_requested():
            try:
                # Wait until access token is almost expired, or wait at least 1 minute
                exp_timestamp = self._renew_schedule or 0
                now_timestamp = utcnow_ts()
                delay_seconds = max(math.ceil(exp_timestamp - now_timestamp), 60)

                if self._renew_task.wait_for_stop(timeout = delay_seconds):
                    # Stop event detected
                    pass
                else:
                    # Reuse access token, renew it, or re-login
                    self.login()

            except Exception as ex:
                _LOGGER.debug(f"Token renew handler caught exception: {ex}")
        
        _LOGGER.debug(f"Token renew handler stopped")
        return True


    def logout(self):
        """Logout"""

        # Only one thread at a time can check token and do subsequent login or logout if needed.
        # Once one thread is done, the next thread can then check the (new) token.
        with self._login_lock:
            self._logout(context="", method=None)

            # Stop token renew
            if self._renew_task is not None:
                self._renew_task.stop()
                self._renew_task = None

            # stop websocket listener
            if self._ws_task is not None:
                self._ws_task.stop()
                self._ws_task = None


    def _logout(self, context: str, method: LoginMethod|None = None):
        """Internal logout handler"""

        # Note: do not call 'async with self._login_lock' here.
        # It will result in a deadlock as login calls _logout from within its lock

        # Sanitize parameters
        context = context.lower() if context else ""

        # Reduce amount of tracing to only when we are actually logged-in.
        if self._login_time and method not in [LoginMethod.ACCESS_TOKEN]:
           _LOGGER.debug(f"Logout")

        # Do not close the http-client. Instead we will simply forget the access-token. 
        # On a next request, the client will act like it is a new one.
        self._access_token = None
        self._access_exp_ts = None

        # Do not clear device token when called in a 'login' context and when we were 
        # only checking the access_token. It is needed for renew-token
        if not (context.startswith("login") and method in [LoginMethod.ACCESS_TOKEN]):
            self._device_token = None
            self._device_exp_ts = None
            self._renew_timestamp = 0

        # Do not clear login_method when called in a 'login' context, as it interferes with 
        # the loop iterating all login methods.
        if not context.startswith("login"):
            self._login_method = None
            self._login_time = None


    def _get_jwt(self, token: str|None, field: str, default:Any=None) -> float:
        """Return the field from the token"""
        try:
            payload = jwt.decode(jwt=token, options={"verify_signature": False})
            return payload.get(field, default)
        except:            
            return default


    def fetch_server_status(self) -> list[dict]:
        """
        Get server status
        """
        # Does not require a prior login...

        _LOGGER.debug(f"Retrieve server status")
        return self._http_request(
            context = f"fetch server-status",
            request = {
                "method": "GET",
                "url": SERVER_API_URL + f'/serverstatus/api/serverstatus/?format=json',
            },
        )
    

    def fetch_site_invited(self) -> list[dict]:
        """
        Get sites the user is invited to
        """
        self.login()

        _LOGGER.debug(f"Retrieve invited sites for user '{self._username}' ({self._user_uuid})")
        result = self._http_request(
            context = f"fetch sites",
            request = {
                "method": "GET",
                "url": PANEL_API_URL + f'/site/invited/',
            },
        )
        return result


    def accept_site_invited(self, site_uuid:str):
        """
        Accept an invite to the site
        """
        self.login()

        _LOGGER.debug(f"accept site invite for {site_uuid}")
        self._http_request(
            context = f"accept site-invite {site_uuid}",
            request = {
                "method": "POST",
                "url": PANEL_API_URL + f'/site/invitation/{site_uuid}/',
            },
        )


    def fetch_sites(self) -> list[dict]:
        """
        Get all sites the user has access to.
        """
        self.login()

        _LOGGER.debug(f"Retrieve own sites for user '{self._username}' ({self._user_uuid})")
        result = self._http_request(
            context = f"fetch sites",
            request = {
                "method": "GET",
                "url": PANEL_API_URL + f'/site/own/',
            },
        )

        # Do a rough parse, we are only interested in remembering
        # mapping from site uuid to site name, panel mac and panel serial
        for site in result:
            site = EliteCloudSite(
                uuid = site.get('uuid'),
                name = site.get('name'),
                panel_mac = site.get('panel',{}).get('mac_address'),
                panel_serial = site.get('panel',{}).get('serial_no'),
            )
            self._sites.append(site)

        # Return entire site list
        return result


    def fetch_site_resources(self, site_uuid:str) -> list[dict]:
        """
        Get sites
        """
        self.login()

        site = self._sites.get_by_uuid(site_uuid)
        if site is None:
            error = f"No site found with id '{site_uuid}'"
            _LOGGER.info(error)
            raise EliteCloudParamError(error)

        result = {}

        _LOGGER.debug(f"Retrieve site areas for '{site.name}' ({site.uuid})")
        result["area"] = self._http_request(
            context = f"fetch site-area {site.uuid}",
            request = {
                "method": "GET",
                "url": PANEL_API_URL + f'/resource/{site.panel_mac}/{site.panel_serial}/area/',
            },
        )

        _LOGGER.debug(f"Retrieve site inputs for '{site.name}' ({site.uuid})")
        result["input"] = self._http_request(
            context = f"fetch site-input {site.uuid}",
            request = {
                "method": "GET",
                "url": PANEL_API_URL + f'/resource/{site.panel_mac}/{site.panel_serial}/input/',
            },
        )

        _LOGGER.debug(f"Retrieve site outputs for '{site.name}' ({site.uuid})")
        result["output"] = self._http_request(
            context = f"fetch site-output {site.uuid}",
            request = {
                "method": "GET",
                "url": PANEL_API_URL + f'/resource/{site.panel_mac}/{site.panel_serial}/output/',
            },
        )

        return result


    def fetch_site_status(self, site_uuid: str):
        """
        Get gatweway
        """
        self.login()

        # If not already done, subscribe to site status
        self._subscribe_site_status(site_uuid)

        # Fetch most recent status
        for retry in range(5):
            status = self._sites_status.get(site_uuid)
            if status is not None:
                return status
            
            time.sleep(1)

        return None


    def subscribe_site_status(self, site_uuid: str, callback):
        """
        Register a callback function that will fire when:
        - On each change of the status
        """
        self.login()

        # Remember callback (overwrite any previous one)
        self._sites_callbacks[site_uuid] = callback

        # Subscribe to site status messages. 
        # May lead to nearly immediate call to the callback.
        self._subscribe_site_status(site_uuid)


    def _subscribe_site_status(self, site_uuid: str, force:bool=False):
        """
        Internal function, not affected by login_lock
        """

        # Already subscribed?
        if site_uuid in self._sites_subscribed and not force:
            return

        site = self._sites.get_by_uuid(site_uuid)
        if site is None:
            error = f"No site found with id '{site_uuid}'"
            _LOGGER.info(error)
            raise EliteCloudParamError(error)

        # Queue the request to subscribe to status changes
        _LOGGER.debug(f"Subscribe to site status updates for site '{site.name}' ({site.uuid})")
        context = f"subscribe site-status {site.uuid}"
        request = {
            "json": {
                "type": "subscribe",
                "body": {
                    "mac_address": site.panel_mac,
                    "serial_no": site.panel_serial,
                },
            }
        }
        self._ws_req_queue.put(request)
    
        # Remember we are subscribed
        self._sites_subscribed.add(site_uuid)


    def _http_request(self, context, request):
        """
        GET or POST a request for JSON data
        """

        # Auto add authorization header
        if self._access_token is not None:
            headers = request.get("headers", {})
            headers["Authorization"] = f"Bearer {self._access_token}"
            request["headers"] = headers
 
        # Perform the request
        dt = utcnow_dt()
        response = None
        flags = request.get("flags", {})
        try:
            rsp = self._http_client.request(
                method = request["method"], 
                url = request["url"],
                params = request.get("params", None), 
                data = request.get("data", None), 
                json = request.get("json", None), 
                headers = request.get("headers", None), 
                follow_redirects = flags.get("redirects", True)
            )

            # Remember actual requests and response params, used for diagnostics
            request["headers"] = rsp.request.headers
            response = {
                "success": rsp.is_success,
                "status": f"{rsp.status_code} {rsp.reason_phrase}",
                "headers": rsp.headers,
                "elapsed": round((utcnow_dt() - dt).total_seconds(), 1),
            }
            if rsp.is_success and rsp.headers.get('content-type','').startswith('application/json'):
                response["json"] = rsp.json()
            else:
                response["text"] = rsp.text

        except Exception as ex:
            error = f"Unable to perform request, got exception '{str(ex)}' while trying to reach {request["url"]}"
            _LOGGER.debug(error)

            # Force a logout to so next login will be a real login, not a token reuse
            self._logout(context)
            raise EliteCloudConnectError(error)

        # Save the diagnostics if requested
        self._add_diagnostics(dt, context, request, response)
        
        # Check response
        if not response["success"]:
            error = f"Unable to perform request, got response {response["status"]} while trying to reach {request["url"]}"
            _LOGGER.debug(error)

            # Force a logout to so next login will be a real login, not a token reuse
            self._logout(context)
            if "401" in response["status"]:
                raise EliteCloudAuthError(error)
            else:
                raise EliteCloudConnectError(error)
        
        if flags.get("redirects",None) == False and response['status'].startswith("302"):
            return response["headers"].get("location", '')

        elif "text" in response:
            return response["text"]
        
        elif "json" in response:
            data = response["json"]
            is_success = data.get("is_success", True)
            status_code = data.get("status_code")
            message = data.get("message")

            if not is_success and status_code >= 300:
                error = f"Unable to perform request, response contains {status_code} '{message}' while trying to reach {request["url"]}"
                _LOGGER.debug(error)

                # Force a logout to so next login will be a real login, not a token reuse
                self._logout(context)
                raise EliteCloudDataError(error)
            
            if "payload" in data:
                return data["payload"]
            
            if "results" in data:
                return data["results"]

            return data
        
        else:
            return None
    

    def _ws_handler(self):
        """
        Parallel task that will handle all websocket operations
        """
        _LOGGER.debug(f"Websocket handler started")

        while not self._ws_task.is_stop_requested():
            # Wait until we get an access token
            if self._access_token is None:
                self._ws_task.wait_for_stop(timeout=1)
                continue

            # (re-)connect
            url = PANEL_API_WS + '/ws/panel/'
            headers = {
                "Authorization": f"Bearer {self._access_token}",
                "Origin": url,
            }
            with httpx_ws.connect_ws(url=url, headers=headers) as ws:

                # Queue any subscribe requests we previously had
                for site_uuid in self._sites_subscribed:
                    self._subscribe_site_status(site_uuid, force=True)

                # Process requests and responses
                while not self._ws_task.is_stop_requested():
                    
                    req_found = False
                    try:
                        # Send if a request is queued
                        if not self._ws_req_queue.empty():
                            request = self._ws_req_queue.get()
                            req_data = request["json"]

                            ws.send_json(req_data)
                            #_LOGGER.debug(f"req: {req_data}")

                            req_found = True
                    
                    except (queue.Empty, TimeoutError):
                        pass

                    except (httpx_ws.WebSocketDisconnect, httpx_ws.WebSocketNetworkError):
                        break   # Exit inner loop and reconnect in outer loop

                    except Exception as ex:
                        _LOGGER.debug(f"WebSocket handler caught exception: {ex}")
                        break   # disconnect and reconnect in outer loop
                    
                    try:
                        # If we could have more requests waiting, only get already available reponse,
                        # otherwise wait and listen for a response to come in
                        rsp_data = ws.receive_json(timeout=0 if req_found else 1)
                        #_LOGGER.debug(f"rsp: {rsp_data}")

                        response = {
                            "json": rsp_data,
                        }
                        self._ws_rsp_queue.put(response)
                    
                    except (queue.Empty, TimeoutError):
                        pass
                    
                    except (httpx_ws.WebSocketDisconnect, httpx_ws.WebSocketNetworkError):
                        break   # Exit inner loop and reconnect in outer loop

                    except Exception as ex:
                        _LOGGER.debug(f"WebSocket handler caught exception: {ex}")
                        break   # disconnect and reconnect in outer loop

        _LOGGER.debug(f"Websocket handler stopped")


    def _ws_rsp_handler(self):
        """
        Parallel task that will handle all responses received via websocket
        """
        _LOGGER.debug(f"Websocket response handler started")

        while not self._ws_rsp_task.is_stop_requested():
            try:
                # Wait if no response is queued
                if self._ws_rsp_queue.empty():
                    self._ws_rsp_task.wait_for_stop(timeout=1)
                    continue
               
                # Get the reponse and process it
                response = self._ws_rsp_queue.get()
                rsp_data = response.get("json", {})
                rsp_type = rsp_data.get("type", "")
                rsp_payload = rsp_data.get("payload", {})

                match rsp_type:
                    case "ready":
                        # Received after a new connect.
                        is_ready = rsp_payload.get("is_ready", False)
                        if is_ready:
                            _LOGGER.info("Websocket connected to remote server")

                    case "subscribe":
                        # Received after a successfull subscribe. Ignore
                        is_success = rsp_payload.get("is_success", False)
                        serial = rsp_payload.get("serial_no", "")

                        site = self._sites.get_by_serial(serial)
                        if is_success and site is not None:
                            _LOGGER.info(f"Subscribed to status updates for site '{site.name}' ({site.uuid})")

                    case "status":
                        # A new status is received
                        status = rsp_payload.get("body", {})
                        panel = rsp_payload.get("panel", {})
                        panel_serial = panel.get("serial_no", "")

                        site = self._sites.get_by_serial(panel_serial)
                        if site is not None:
                            _LOGGER.info(f"Received status update for '{site.name}' ({site.uuid})")

                            # Remember the most recent status for each site
                            self._sites_status[site.uuid] = status

                            # Call status callback for this site (if any)
                            callback = self._sites_callbacks.get(site.uuid)
                            if callback is not None:
                                callback(site, status)

            except queue.Empty:
                pass
            
            except Exception as ex:
                _LOGGER.debug(f"WebSocket response handler caught exception: {ex}")
                pass

        _LOGGER.debug(f"Websocket response handler stopped")


    def _add_diagnostics(self, dt: datetime, context: str, request: dict|None, response: dict|None, token: dict|None = None):
        """Gather diagnostics"""

        if not self._diag_collect:
            return

        method = request.get("method", "unknown") if request is not None else None
        method = method.replace("GET", "HttpGet").replace("POST", "HttpPost") if method is not None else None

        duration = response.get("elapsed", None) if response is not None else None
        duration = round(duration, 0) if duration is not None else None
        
        history_item = EliteCloudHistoryItem.create(dt, context, request, response, token)
        history_detail = EliteCloudHistoryDetail.create(dt, context, request, response, token)

        # Call durations
        if duration is not None:
            if duration in self._diag_durations:
                self._diag_durations[duration] += 1
            else:
                self._diag_durations[duration] = 1

        # Call method
        if method is not None:
            if method in self._diag_methods:
                self._diag_methods[method] += 1
            else:
                self._diag_methods[method] = 1

        # Call counters
        if context in self._diag_counters:
            self._diag_counters[context] += 1
        else:
            self._diag_counters[context] = 1

        # Call history        
        self._diag_history.append(history_item)
        while len(self._diag_history) > 64:
            self._diag_history.pop(0)

        # Call details
        self._diag_details[context] = history_detail


    def get_diagnostics(self) -> dict[str, Any]:
        """Return the gathered diagnostics"""

        data = {
            "login_time": self._login_time,
            "login_method": self._login_method,
        }

        calls_total = sum([ n for key, n in self._diag_counters.items() ]) or 1
        calls_counter = { key: n for key, n in self._diag_counters.items() }
        calls_percent = { key: round(100.0 * n / calls_total, 2) for key, n in calls_counter.items() }

        durations_total = sum(self._diag_durations.values()) or 1
        durations_counter = dict(sorted(self._diag_durations.items()))
        durations_percent = { key: round(100.0 * n / durations_total, 2) for key, n in durations_counter.items() }

        methods_total = sum(self._diag_methods.values()) or 1
        methods_counter = dict(sorted(self._diag_methods.items()))
        methods_percent = { key: round(100.0 * n / methods_total, 2) for key, n in methods_counter.items() }
        
        return {
            "data": data,
            "diagnostics": {
                "dt": utcnow_dt(),
                "durations": {
                    "counter": durations_counter,
                    "percent": durations_percent,
                },
                "methods": {
                    "counter": methods_counter,
                    "percent": methods_percent,
                },
                "calls": {
                    "counter": calls_counter,
                    "percent": calls_percent,
                },
            },
            "history": self._diag_history,
            "details": self._diag_details,
        }
